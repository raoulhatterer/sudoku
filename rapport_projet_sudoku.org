#+STARTUP: inlineimages
#+LANGUAGE: fr
#+LATEX_COMPILER: xelatex 
#+LATEX_HEADER: \usepackage{fontspec}
#+LaTeX_HEADER: \usepackage{xunicode}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
#+LaTeX_HEADER: \usepackage[x11names]{xcolor}
#+LaTeX_HEADER: \hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue4, citecolor = PaleGreen1, linkcolor = black}
#+LATEX_HEADER: \usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
#+TITLE: Diplôme Inter-Universitaire
#+SUBTITLE: Projet Sudoku
#+AUTHOR: Raoul HATTERER & Jean-Luc COSSALTER 
#+OPTIONS: tooc:3

* Introduction
  Nous avons réalisé trois versions du jeu de Sudoku. La première utilise une pile et remplit la grille au fur et à mesure en s'assurant que les symboles déjà placés autorisent le placement. La seconde utilise les méthodes de résolution classiques comme singleton nu, singleton caché, élimination indirecte, XWING, SWORD-fish, etc. Enfin, la troisième version est une version web qui permet de jouer et de vérifier la grille en utilisant Javascript.    

* Première version
** L'interface homme-machine
*** Au démarrage
    Au démarrage (figure [[fig:au_demarrage]]) la grille de Sudoku apparaît vide au centre de la fenêtre.
    Sur la gauche, la jauge de remplissage est vide.
    La pioche, au bas de la fenêtre, indique que neuf symboles de chaque sorte restent à placer sur la grille.

    Sur la droite, un bouton *Nouvelle partie* de couleur distinctive permet d'amorcer une nouvelle partie.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: au démarrage
    #+NAME:   fig:au_demarrage
    [[file:./images/au_demarrage.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Nouvelle partie
    La grille est tirée de façon aléatoire et secrète.
    La pioche, au bas de la fenêtre (figure [[fig:choix_du_niveau]]) est vide: elle indique que tous les symboles ont été placés sur la grille.
    Sur la gauche, la jauge de remplissage est pleine.
    Sur la droite, un curseur est apparu, il permet de choisir le niveau de difficulté. Un bouton *Commencer* de couleur distinctive permet au joueur de commencer la partie.
    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: choix du niveau
    #+NAME:   fig:choix_du_niveau
    [[file:./images/choix_du_niveau.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Début de partie 

    La grille pleine est vidée aléatoirement jusqu'à atteindre le niveau souhaité par le joueur. 
    La jauge de remplissage et la pioche se retrouvent partiellement remplies.
    La grille est révélée au joueur et les cases dors et déjà remplies sont gelées : le joueur ne peut plus ni les effacer ni les modifier.
    Sur la gauche, le chronomètre est mis en marche et décompte le temps qui s'écoule.  


    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: début de partie
    #+NAME:   fig:début_de_partie
    [[file:./images/debut_de_partie.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Placer un symbole sur la grille

    Pour placer un symbole sur la grille, le joueur commence par sélectionner le symbole qu'il souhaite placer soit en le choisissant sur la grille, soit en le choisissant dans la pioche. Le symbole sélectionné apparaît alors d'une couleur distinctive (figure [[fig:selectionner_un_symbole]]).

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: sélectionner un symbole
    #+NAME:   fig:selectionner_un_symbole
    [[file:./images/selectionner_un_symbole.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    Le joueur clique alors sur une case vide pour y placer le symbole.
    Si la case est susceptible d'accepter le symbole celui est placé (figure [[fig:placer_un_symbole]]). 
    La pioche et la jauge de remplissage évoluent en conséquence.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: placer un symbole
    #+NAME:   fig:placer_un_symbole
    [[file:./images/placer_un_symbole.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Effacer un symbole de la grille
    Pour effacer un symbole, le joueur sélectionne le  bouton d'effacement *X* à droite de la pioche. Ce bouton apparaît alors en rouge (figure [[fig:effacer_un_symbole]]).
    Ce bouton agit en bascule: si le joueur clique dessus une nouvelle fois, on sort du mode effacement. On peut aussi en sortir en sélectionnant un autre symbole.

    Quand le mode effacement est actif, à chaque fois que le joueur clique sur une case pleine de la grille, celle-ci est effacée.
    La pioche et la jauge de remplissage évoluent en conséquence.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: effacer un symbole
    #+NAME:   fig:effacer_un_symbole
    [[file:./images/effacer_un_symbole.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Menus

    En haut de la fenêtre se trouve la barre de menu qui comporte:
    - le menu fichier (figure [[fig:menu_fichier]]) qui permet notamment d'ouvrir un fichier (figure [[fig:ouvrir]]). Le format *sdk* n'est pas encore implémenté, il faut donc utiliser le format *csv*.
    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: menu fichier
    #+NAME:   fig:menu_fichier
    [[file:./images/menu_fichier.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: ouvrir un fichier
    #+NAME:   fig:ouvrir
    [[file:./images/ouvrir.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    - le menu langue (figure [[fig:langue]]) permet de choisir la langue de l'interface parmi français, anglais (figure [[fig:anglais]]) et grec.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: choix de la langue
    #+NAME:   fig:langue
    [[file:./images/choix_langue.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: interface en anglais
    #+NAME:   fig:anglais
    [[file:./images/anglais.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    - le menu afficher (figure [[fig:afficher]]) qui permet d'afficher les *outils développeur* (figure [[fig:outils]]), le  *chronomètre* et une fenêtre *À propos*.
    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: menu afficher
    #+NAME:   fig:afficher
    [[file:./images/menu_afficher.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link


    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: les outils sont affichés au dessus du chronomètre
    #+NAME:   fig:outils
    [[file:./images/outils.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

    Si le joueur renonce à remplir la grille, il peut recourir au solveur. S'il a déjà placé des symboles sur la grille, il doit cliquer sur *Recommencer* puis sur *Solveur*. 

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: victoire
    #+NAME:   fig:victoire
    [[file:./images/victoire.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

*** Aides
    Le joueur peut activer des aides en cochant les cases aides qui sont situées en haut, à droite de la grille. 
    - l'aide =Grille= permet d'afficher (en haut à droite) les prétendants au survol des cases (figure [[fig:pretendants]]). Au départ, toutes les cases admettent les neuf symboles comme prétendants. Puis, au fur et à mesure du remplissage, les symboles présents dans les cases cousines de la même ligne, colonne ou bloc 3x3 sont déduites de la liste des prétendants.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: prétendants
    #+NAME:   fig:pretendants
    [[file:./images/pretendants.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link
  
    - l'aide =Pioche= permet d'indiquer (figure [[fig:destinations]] à gauche du *X*) les destinations envisageables pour les symboles de la pioche si l'on survole le cardinal de la pioche quand un symbole est sélectionné. Le bouton *Index cases* permet de révéler de façon transitoire les index des cases tant que le bouton de la souris est maintenu enfoncé.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: destinations
    #+NAME:   fig:destinations
    [[file:./images/destinations.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link

** Le code
*** Documentation
    Le code est documenté par /docstring/ python. Cela procure une documentation accessible depuis la console. 
    Par exemple, la classe ~Case~ (listing [[prog:code_class_Case]]) à une documentation intégrée accessible en tapant ~help(Case)~ dans la console python.

    #+CAPTION: la classe ~Case~ comporte énormément de documentation 
    #+NAME:   prog:code_class_Case
    #+INCLUDE: "sudoku.py" src python -n 30 :lines "30-63"

    Il en va de même pour toutes les classes utilisées dans le programme:
    - la classe ~Case~ 
    - la classe ~Grille~ qui utilise la classe ~Case~ (listing [[prog:code_class_Grille]]) tout en disposant d'attributs et de méthodes propres (listing [[prog:code_class_Grille_methodes]]).
    - la classe ~Watchdog~ utilisée lors du tirage
    - la classe ~Sac~. Un sac contient des symboles identiques.
    - la classe ~Pioche~. Classe utilisant 9 sacs contenant chacun des symboles identiques tous différents (1 sac avec que des "1", un autre avec que des "2", etc.)

    #+CAPTION: la classe Grille fait appel à la classe Case
    #+NAME:   prog:code_class_Grille
    #+INCLUDE: "sudoku.py" src python -n 208 :lines "208-233"

    #+CAPTION: attributs et méthodes de la classe Grille
    #+NAME:   prog:code_class_Grille_methodes
    #+INCLUDE: "sudoku.py" src python -n 123 :lines "123-164"

    Il en va de même pour toutes les fonctions utilisées dans le programme: elles sont, elles aussi, documentées par /docstring/.

*** Multiplateforme
    Python et tkinter sont théoriquement multiplateformes mais l'apparence est différente suivant la plateforme utilisée.
    Globalement tkinter fonctionne mieux sous Linux que sous Windows (on perd le changement d'aspect du bouton au survol de la souris) ou sous mac OSX (idem, de plus le ~background~ des boutons doit être obtenu de façon détournée et les fenêtre Toplevel sont mal gérées).

** La démarche
*** Réflexion initiale
    - Ne pas consulter de documentation sur les méthodes de résolution pour essayer d'établir une méthode personnelle.
    - Chaque case vide à des prétendants (symboles que l'ont peut envisager de placer dans la case). La liste des prétendants se réduit au fur et à mesure que la grille se remplit car il faut retirer les symboles placés dans les cases cousines (cases de même ligne, colonne ou bloc). Je me propose donc de gérer les prétendants pour chacune des cases de la grille (d'où le menu d'aide =Grille= qui fait apparaître les prétendants).
    - Les symboles sont prélevés dans une pioche qui comporte 9 sacs contenant chacun des symboles identiques. Au départ, il y a 81 destinations possibles pour le premier symbole à placer. Le nombre de destinations possibles pour le second symbole à placer n'est pas forcément de 80 car, si le second symbole est le même que le premier, il ne peut pas être placé dans une case cousine du premier. Je me propose donc de  gérer les destinations pour chacun des neuf symboles au cours de la partie (d'où le menu d'aide =Pioche= qui fait apparaître les destinations).
*** Tirage d'une grille
    - aléatoirement, je place le premier '1' dans une des 81 cases, puis le deuxième '1' aléatoirement dans une des destinations restantes, etc. Chaque placement est stocké dans une pile. Si l'on arrive à une impasse (case sans contenu ni prétendants) on remonte dans la pile et on choisi aléatoirement une autre destination envisageable parmi les destinations non testées. 
    - Pour gagner en efficacité, je rajoute un watchdog. Si l'on remonte plus de 4 niveaux dans la pile, le watchdog se déclenche et provoque l'effacement des '1' car placés en premier avec plein de destinations à leur disposition, ils ont peut être adopté une configuration problématique pour le placement des autres symboles. Les '1' sont renvoyés en fin de liste des symboles à placer. Si le watchdog se déclenche à nouveau, les '2' sont à leur tour renvoyés en fin de liste, etc. Pour éviter de rentrer dans un cercle vicieux qui consisterait à renvoyer les symboles en fin de liste les uns après les autre, la profondeur de déclenchement du watchdog augmente au cours des déclenchements. 
    - Réglage du niveau: on part d'une grille pleine obtenue par tirage. Puis on réalise la suppression aléatoire des symboles de la grille qui sont replacés dans la pioche  jusqu'à parvenir au taux de remplissage souhaité par le joueur. Cette méthode ne garantit pas l'unicité de la solution mais, peu importe, car si le joueur parvient à placer tous les symboles sur la grille la victoire lui est accordée (même si la grille pleine tirée au départ était différente).  
*** Solveur 
    - Pas indispensable par pouvoir avoir un jeu fonctionnel (sauf si l'on tient à s'assurer de l'unicité) mais réalisé tout de même.
    - Première tentative: utiliser le mécanisme du tireur sans watchdog... fonctionne en théorie mais la résolution est beaucoup mais alors beaucoup trop longue car des permutations équivalentes sont testées comme étant des propositions différentes .  
    - Solution : s'inspirer du tireur mais utiliser des ensembles de symboles plutôt que de placer un symbole après l'autre. 
    - Par exemple, sur la figure [[fig:destinations]] à gauche du *X* on peut voir que les cinq symboles '8' de la pioche peuvent être placés sur onze cases dont les index sont connus. Grâce à la fonction ~nCr(n, r)~ qui retourne le nombre de combinaisons de n objets pris r à r, on calcule le nombre de combinaisons de 5 symboles '8' parmi 11 destinations. Il y en a 462.   
    - On fait de même pour les autres symboles de la pioche. Cela nous permet de déterminer dans quel ordre on va placer les symboles. En commençant par placer ceux qui ont le plus petit nombre de combinaisons cela va diminuer le nombre de destinations possibles pour les autres et donc limiter le nombre de combinaisons possibles pour eux.
    - On détermine les combinaisons grâce à la fonction ~combinations~ du module ~itertools~ (listing [[prog:determine_combinaisons_Sac]]) puis on purge la liste en conservant celles qui sont possibles (listing [[prog:determine_combinaisons_Grille]]). La purge est drastique: pour un nombre de combinaisons allant typiquement de quelques centaines à quelques milliers on se retrouve avec un nombre de combinaisons valables se comptant sur les doigts d'une seule main.


    #+CAPTION: détermination des combinaisons (classe Sac) 
    #+NAME:   prog:determine_combinaisons_Sac
    #+INCLUDE: "sudoku.py" src python -n 1173 :lines "1173-1180"

    #+CAPTION: détermination des combinaisons (classe Grille) 
    #+NAME:   prog:determine_combinaisons_Grille
    #+INCLUDE: "sudoku.py" src python -n 815 :lines "815-849"
     
     
    - Aléatoirement, on place le premier ensemble de symboles dans une des destinations valables et parallèlement on sauvegarde cela dans une pile. On passe ensuite à l'ensemble suivant et on fait de même, etc. Quand on arrive à une impasse (car l'ensemble suivant se retrouve sans destinations valables) on remonte dans la pile et on choisit aléatoirement un autre ensemble parmi l'ensemble des destinations valables.
    - Ce mécanisme fonctionne parfaitement bien et fini toujours par trouver une solution si celle-ci existe.
    - Commentaires :
      - Si plusieurs solutions existe la première solution rencontrée est retenue.
      - Si le solveur est relancé pour résoudre la même grille, il déterminera la solution dans un temps différent à chaque tentative car le parcours des destinations valables se fait de façon aléatoire.
      - Pour la même raison, si plusieurs solutions existent, le solveur ne tombera pas forcement sur la même à chaque fois.
    - Pour gagner en efficacité, le solveur par pile est précédé d'un traitement des single-tons. Tant que la grille possède des cases admettant un seul prétendant, elles sont remplies puis on passe au traitement par pile.
    - Lorsque le traitement par pile est mis en oeuvre, une jauge de parcours des combinaisons est affichée sous la grille.

    #+attr_html: :width 60%
    #+attr_latex: :width 300pt
    #+CAPTION: jauge de parcours sous la grille
    #+NAME:   fig:jauge_de_parcours
    [[file:./images/jauge_de_parcours.png]]
    # # C-c C-x C-v toggle preview
    # # C-c C-o to follow link
* Deuxième version

** L'interface homme-machine
   Cette interface a été réalisée à l'aide de la librairie TKinter. Elle permet :
   - La visualisation de la grille. Les chiffres de départ sont en noir, ceux placés sont en vert.
   - De choisir un chiffre (barre verte) pour ensuite pouvoir le placer dans la grille.
   - D'effacer un chiffre (gomme).
   - D'effacer tous les chiffres placés (bouton *Recommencer*).
   - De résoudre la grille (bouton *Résoudre*).
   - De créer une nouvelle grille avec un niveau de difficulté allant de 0 à 20 (bouton Nouveau.
   - De charger une partie ou de la sauvegarder au format csv (boutons Charger et Enregistrer)
   - De quitter le jeu (bouton *Quitter*).

*** Partie affichage : Grille, barre des chiffres et gomme
    Cette partie est gérée par la fonction Clic

    Elle analyse la position X,Y du clic pour pouvoir agir en conséquence :
    - Clic sur la barre verte : le chiffre correspondant est enregistré (dans la variable =chiffre=)
    - Clic sur la gomme =chiffre= est mis à 0 ce qui correspond à une case vide.
    - Clic sur la grille : si =chiffre= est entre 0 et 9 et que l'on clique sur une case vide, cette case prend la valeur de =chiffre=. =chiffre= est ensuite mis à 10 pour éviter la répétition.
*** Partie menu : boutons
    Nous avons utilisé des widgets boutons auxquels nous avons associé des fonctions qui sont exécutées lorsque le bouton est cliqué : Résoudre, Recommencer, Charger …

    Associé au bouton *Nouveau*, il y a un widget =Spinbox= qui permet de sélectionner un niveau de difficulté de 0 à 20. Cette valeur passe en paramètre pour la fonction =création_aléatoire=.

    Pour les bas niveaux on ne supprime que les des cases que l'on peut retrouver (1 seul prétendant), seul le nombre varie en fonction du niveau.

    Puis plus on sélectionne un niveau élevé, plus il y a de cases vides, et plus les méthodes pour trouver les chiffres sont complexes. Ceci jusqu'au niveau 19.

    À niveau 20, on ne génère que des grilles avec 17 cases remplies au départ.

    Partie Charger Enregistrer : En plus des boutons, on a utilisé un widget =Entry= qui permet de sélectionner le fichier. Il est inutile de spécifier l'extension .csv qui est rajoutée automatiquement.

    La fonction Enregistrer enregistre 2 grilles au format .csv : la grille de départ et la grille dans son état actuel. Ceci pour reprendre une partie par exemple.

    La fonction charger charge la grille initiale si elle est seule ou la grille enregistrée si celle-ci existe.

** Explications sur les fonctions utilisées
*** Intersection
    #+CAPTION: intersection de deux listes
    #+NAME:   FoncSudo:intersection_2_listes
    #+INCLUDE: "FoncSudo.py" src python -n 14 :lines "14-25"

    On passe à la fonction =intersection_2_listes= (listing [[FoncSudo:intersection_2_listes]]) deux paramètres qui sont des listes (=L1= et =L2=).
    - Si une des deux  liste est vide (on teste si la longueur d'une des liste est nulle) alors l'intersection est vide et l'on renvoie une liste vide 
    - Sinon on compare tous les éléments de la première avec tous ceux de la deuxième et si l'on trouve un élément commun on le rajoute à la liste résultat à condition que l'on ne l'ai pas déjà rajouté. Une fois les comparaisons terminées, on renvoie la liste des éléments communs.

*** Tests sur les listes
    #+CAPTION: présence des 9 chiffres
    #+NAME:   FoncSudo:est_complet
    #+INCLUDE: "FoncSudo.py" src python -n 27 :lines "27-38"

    La fonction =est_complet= (listing [[FoncSudo:est_complet]]) est utilisée pour savoir si dans une liste on a bien tous les nombres de 1 à 9 une fois. Cette fonction renvoie =True= ou =False=. 

    On passe à cette fonction un paramètre qui est la liste :  =a_tester=.
    Pour tous les éléments de la liste, obtenus en faisant varier index de 0 à 8 on teste si les éléments de la liste =a_tester= sont dans la liste de départ : =liste=. S'ils le sont on enlève l'élément de la liste de départ =liste=, sinon on renvoie =False=. À la fin, si aucun élément ne manque on renvoie =True=.

    #+CAPTION: pour savoir les chiffres qui restent
    #+NAME:   FoncSudo:reste
    #+INCLUDE: "FoncSudo.py" src python -n 40 :lines "40-47"


 
    La fonction =reste= (listing [[FoncSudo:reste]]) est utilisée pour savoir quels sont les éléments qui restent par rapport à la liste des nombres de 1 à 9. Pour la grille de sudoku, cette fonction est utile pour connaître les possibilités qui restent dans une case en éliminant peu à peu tous les éléments qui sont impossibles.

    On passe à cette fonction un paramètre : la liste : =liste_a_tester= et la fonction renvoie les éléments restants. On passe en revue tous les éléments de la =liste_a_tester= et s'ils sont dans la liste on les retire de celle-ci. À la fin la fonction renvoie  ce qui reste de la liste.

*** Les tests de remplissage

    #+CAPTION: teste si les 9 chiffres sont presents dans toutes les lignes
    #+NAME:   FoncSudo:teste_ligne
    #+INCLUDE: "FoncSudo.py" src python -n 49 :lines "49-60"
 
    La fonction =teste_ligne= (listing [[FoncSudo:teste_ligne]]) est utilisée pour savoir si les 9 chiffres sont présents dans les 9 lignes de la grille.

    On passe en paramètre la grille à tester et la fonction retourne =True= si les 9 chiffres sont présents dans toutes les lignes ;  elle retourne =False= sinon. Cette fonction fait appel à la fonction =est_complet= décrite précédemment. Pour chaque ligne de la grille à tester, on crée une liste (=mot_a_tester=) est on teste si  cette liste est complète ou non.

    # #+CAPTION: teste si les 9 chiffres sont presents dans toutes les colonnes
    # #+NAME:   FoncSudo:teste_colonne
    # #+INCLUDE: "FoncSudo.py" src python -n 61 :lines "61-73"
 
    Une fonction équivalente appelée  =teste_colonne= est  utilisée pour savoir si les 9 chiffres sont présents dans les 9 colonnes de la grille. 

    #+CAPTION: teste si les 9 chiffres sont présents dans tous les carrés
    #+NAME:   FoncSudo:teste_carre
    #+INCLUDE: "FoncSudo.py" src python -n 75 :lines "75-87"
 
    La fonction =teste_carre= (listing [[FoncSudo:teste_carre]]) est  utilisée pour savoir si les 9 chiffres sont présents dans les 9 carrés de la grille. 

    =[i % 3 + 3 * (carre % 3)][i // 3 + 3 * (carre // 3)]=, permet d'obtenir la position =[ligne][colonne]= d'un élément de la grille en fonction du numéro du carré et de la position =i= de l'élément.


    #+CAPTION: teste si les 9 chiffres sont presents LCC
    #+NAME:   FoncSudo:test_complet
    #+INCLUDE: "FoncSudo.py" src python -n 88 :lines "88-99"
 
    La fonction =test_complet= (listing [[FoncSudo:test_complet]]) utilise les 3 fonctions précédentes.
    On lui passe en paramètre la grille à tester. 
    Elle retourne =True= si tous les chiffres sont présents dans toutes les lignes, toutes les colonnes et tous les carrés.  Sinon elle retourne =False=.

    Cette fonction permet de savoir si la grille de sudoku est bien remplie.

*** Tests pour la résolution
    #+CAPTION: quels sont les chiffres qui restent à mettre dans une  colonne
    #+NAME:   FoncSudo:reste_colonne
    #+INCLUDE: "FoncSudo.py" src python -n 101 :lines "101-107"
 
    La fonction =reste_colonne= (listing [[FoncSudo:reste_colonne]]) va fournir la liste des éléments qui rentent à placer dans une colonne.

    On lui passe en paramètre la grille à tester et un numéro de colonne. Cette fonction crée une liste constituée des éléments de la colonne spécifiée : =mot_a_tester=, elle retourne la liste des éléments  non encore placés en utilisant la fonction reste vue précédemment. 

    #+CAPTION: quels sont les chiffres qui restent à mettre dans un carré
    #+NAME:   FoncSudo:reste_carre
    #+INCLUDE: "FoncSudo.py" src python -n 116 :lines "116-124"

    De façon similaire, on réalise la fonctions =reste-ligne= et la fonction  =reste_carré= (listing [[FoncSudo:reste_carre]]) qui respectivement vont fournir la liste des éléments qui restent à placer dans une ligne et la liste des éléments qui rentent à placer dans un carré.
   
    =position_carre=3*(ligne//3)+colonne//3=  permet de déterminer la position du carré en fonction de la ligne et de la colonne.

    Pour tous les éléments du carré trouvé, on ajoute à la liste =mot_a_tester= tous les éléments du carré. On renvoie le reste en utilisant la fonction reste (listing [[FoncSudo:reste]]).
 

    #+CAPTION: finalement aux coordonnées données que reste-t-il comme chiffre possible ?
    #+NAME:   FoncSudo:reste_possible
    #+INCLUDE: "FoncSudo.py" src python -n 126 :lines "126-137"
 
    La fonction =reste_possible= (listing [[FoncSudo:reste_possible]]) va déterminer pour une case du sudoku quels sont les candidats possibles.

    On passe en paramètre:
    - la grille à tester
    - la ligne d'un élément
    - la colonne de l'élément.

    On détermine quels sont les candidats possibles pour une case de la grille (dans la ligne, dans la colonne et dans le carré). On fait ensuite l'intersection ce ces 3 ensembles pour pouvoir retourner le reste des candidats possibles.

    Si la case est déjà remplie (valeur non nulle), on retourne une liste vide.

*** Fonctions pour la création des grilles (grilles simples par soustraction)
 
    #+CAPTION: reste possible pour la création des grilles
    #+NAME:   FoncSudo:reste_possible_creation
    #+INCLUDE: "FoncSudo.py" src python -n 140 :lines "140-148"
 
    La fonction =reste_possible_creation= (listing [[FoncSudo:reste_possible_creation]]) est la même fonction que la précédente, mais qui ne renvoie pas une liste vide lorsque l'élément est présent. 
 
    #+CAPTION: inverser 2 chiffres d'une grille
    #+NAME:   FoncSudo:inverser_nombres_grille
    #+INCLUDE: "FoncSudo.py" src python -n 154 :lines "154-165"
 
    La fonction =inverser_nombres_grille= (listing [[FoncSudo:inverser_nombres_grille]]) sert à inverser 2 chiffres d'une grille. Ceci permet de créer une grille différente de celle d'origine.

    On passe en paramètre :
    - le nom de la grille (=tab=)
    - les deux chiffres à échanger
    La fonction renvoie la grille avec les deux chiffres échangés.
    Dans la grille, on passe en revue toutes les lignes (indice =i=) et toutes les colonnes (indice =j=). Si dans une case on trouve un des deux chiffres on l'échange avec l'autre. La variable =fait= est mise à =False= au départ et elle passe à =True= dès que l'échange a été fait, ceci pour ne pas échanger deux fois le contenu de la case lorsque l'on tombe sur =nombre1=.

    Cette fonction n'est plus utilisée car la fonction =melange_nombre_grille= (listing [[FoncSudo:melange_nombre_grille]]) permet de mélanger tous les nombres d'un seul coup.

    #+CAPTION: inverser 2 lignes
    #+NAME:   FoncSudo:inverser_lignes
    #+INCLUDE: "FoncSudo.py" src python -n 178 :lines "178-188"
 
    Des fonctions =inverser_colonnes= et =inverser_lignes= (listing [[FoncSudo:inverser_lignes]]) permettent d'inverser 2 colonnes ou 2 lignes d'une grille. Ceci permet de créer une grille différente de celle d'origine.

    On passe en paramètre :
    - le nom de la grille (=tab=)
    - les deux lignes ou colonnes à échanger

    La fonction renvoie la grille avec les deux lignes (ou colonnes) échangées.

    La ligne:     =if ligne1//3==ligne2//3= permet de vérifier que l'échange se fait dans les mêmes carrés, sinon on créerait une grille fausse.

    Pour le reste on fait simplement un échange en passant par une variable temporaire =temp=.
     
    #+CAPTION: mélange aléatoire des nombres d'une grille
    #+NAME:   FoncSudo:melange_nombre_grille
    #+INCLUDE: "FoncSudo.py" src python -n 140 :lines "140-148"
 
    La fonction =melange_nombre_grille= (listing [[FoncSudo:melange_nombre_grille]]) permet de mélanger aléatoirement les nombres d'une grille ce qui permet de créer des grilles différentes à partir d'une grille de départ.

    On part d'une liste =chiffres_melanges= : =[1,2,3,4,5,6,7,8,9]= que l'on mélange aléatoirement avec la fonction =shuffle=, son ordre est donc quelconque. On passe en revue à l'aide de 2 boucles =for= imbriquées (indices =i= et =j=) tous les éléments de la grille =tab= et on remplace le chiffre de départ  si celui-ci est positif (le zéro correspond à une case vide) par le contenu du tableau =chiffres_melanges= dont le rang est le chiffre de départ -1 (pour commencer les indices à 0).

    #+CAPTION: mélange aléatoire 3 grandes colonnes
    #+NAME:   FoncSudo:change_3_col
    #+INCLUDE: "FoncSudo.py" src python -n 204 :lines "204-220"
 
    La fonction =change_3_col= (listing [[FoncSudo:change_3_col]]) permet de mélanger aléatoirement 3 grandes colonnes ce qui permet de créer des grilles différentes à partir d'une grille de départ.

    On part d'un tableau (grille de sudoku), on crée 2 listes contenant 0, 1, 2 : 
    - =a= dans l'ordre
    - =b= dans un ordre aléatoire après l'utilisation de la fonction shuffle.
    On recopie le tableau dans un tableau temporaire : =tab_temp=
    Puis on recopie ce tableau temporaire dans le tableau de départ en mélangeant les 3 grandes colonnes. =[(b[colon//3]-a[colon//3])*3+colon]= va permettre de mélanger les colonnes par groupes  de 3 : on pourra par exemple obtenir 345012678 ce qui va permettre d'échanger les colonnes 012 avec les 345 la colonne 678 restant en place.
    Il y a 3! = 6 combinaisons possibles.

    # #+CAPTION: mélange aléatoire 3 grandes lignes
    # #+NAME:   FoncSudo:change_3_lign
    # #+INCLUDE: "FoncSudo.py" src python -n 224 :lines "224-240"
 
    De même, une fonction =change_3_lign= permet de mélanger aléatoirement 3 grandes lignes ce qui permet de créer des grilles différentes à partir d'une grille de départ.C'est la même fonction que la précédente, mais appliquée aux lignes à la place des colonnes.

    #+CAPTION: mélange aléatoire de 3 petites colonnes
    #+NAME:   FoncSudo:change_3_petites_col
    #+INCLUDE: "FoncSudo.py" src python -n 245 :lines "245-269"
 
    La fonction =change_3_petites_col= (listing [[FoncSudo:change_3_petites_col]]) permet d'échanger aléatoirement les 3 petites colonnes des 3 grandes colonnes d'une grille. Ceci permet de créer des grilles différentes à partir d'une grille de départ.

    On commence par copier le tableau (=grille=) dans un tableau temporaire. On mélange =b= avec la fonction =shuffle=. On recopie les 3 premières colonnes en changeant l'ordre de celles-ci (on remplace le numéro de colonne par la valeur de b d'indice le numéro en question). 

    Idem avec les 3 colonnes suivantes et les 3 dernières.

    # #+CAPTION: mélange aléatoire de 3 petites lignes
    # #+NAME:   FoncSudo:change_3_petites_lignes
    # #+INCLUDE: "FoncSudo.py" src python -n 273 :lines "273-296"

    De même on réalise une fonction =change_3_petites_lignes= qui mélange 3 petites lignes.

    #+CAPTION: supprime la valeur d'une case aléatoirement
    #+NAME:   FoncSudo:supprimer_nombre
    #+INCLUDE: "FoncSudo.py" src python -n 297 :lines "297-317"



    Les fonctions =supprimer_nombre_simple= et =supprimer_nombre= ([[FoncSudo:supprimer_nombre]]) peuvent être utilisées pour la création de grilles nouvelles.

    On leur passe en paramètre une grille complète ou partiellement complète elles renvoient cette même grille avec eventuellement une case mise à 0.


    La fonction =supprimer_nombre_simple= :
    - Tire 2 coordonnées (ligne, colonne)  aléatoirement entre 0 et 8
    - Si à ces coordonnées il y a une valeur que l'on peut trouver directement, on la supprime de la 
    grille. Cette fonction permet de générer des grilles pour débutants.


    La fonction =supprimer_nombre= :
    - Tire 2 coordonnées (ligne, colonne)  aléatoirement entre 0 et 8
    - On crée une copie de la grille
    - On supprime la valeur de la case tirée aléatoirement sur la copie
    - On essaie de résoudre (par les fonctions de résolution) cette copie de grille.
    - Si on a pu résoudre, on enlève la valeur de la grille et on la retourne.


    #+CAPTION: création aléatoire de grille
    #+NAME:   FoncSudo:creation_aleatoire
    #+INCLUDE: "FoncSudo.py" src python -n 323 :lines "323-374"
 
    La fonction =creation_aleatoire= (listing [[FoncSudo:creation_aleatoire]]) permet de créer une grille aléatoirement :
    - On part d'une grille quelconque (pleine ou partiellement remplie)
    - On utilise les fonctions de mélange (chiffres, colonnes, lignes, petites colonnes et petites lignes) pour créer une grille différente.
    - On supprime ensuite (avec fonction =supprimer_nombre=) des valeurs de la grille
    - On recopie la grille créée pour avoir la grille de départ.
    - Et l'on renvoie ensuite ces 2 mêmes grilles. La grille de départ aura une couleur d'affichage différente et ne pourra pas être effacée.

** Les fonctions de résolution
 
   #+CAPTION: grille des possibles
   #+NAME:   FoncSudo:grille_des_possibles
   #+INCLUDE: "FoncSudo.py" src python -n 395 :lines "395-403"
 
   La fonction =grille_des_possibles= (listing [[FoncSudo:grille_des_possibles]]) en elle-même ne résout rien, mais elle crée un tableau =gdp= image de la grille de départ qui au lieu de contenir les valeurs contient la liste des prétendants.

   Pour chaque ligne de la grille, on crée une ligne des possibles (=ldp=)  contenant tous les restes possibles de la ligne et on l'ajoute à la grilles des possibles (=gdp=). Lorsque celle-ci est pleine, la fonction la retourne.

*** Première fonction de résolution:  =ou_le_nombre_peut_etre=

    #+CAPTION: Première fonction de résolution (singleton et élimination indirecte)
    #+NAME:   FoncSudo: ou_le_nombre_peut_etre_singleton
    #+INCLUDE: "FoncSudo.py" src python -n 405 :lines "405-455"
 

    La fonction =ou_le_nombre_peut_etre= (listing [[FoncSudo: ou_le_nombre_peut_etre_singleton]]) va rechercher dans quelles cases un nombre peut être placé.
    On crée pour cela un tableau =possible= de même dimension que la grille qui contiendra 0 si le 
    nombre ne peut pas être à la position et 1 si le nombre peut être à la position.
    Au départ toutes les cases sont possibles et l'on place la valeur 1 dans toutes les cases.
    Ensuite au fur et à mesure on va éliminer les possibilités en placant des 0.

**** Recherche d'un singleton caché
     On étudie une à une les cases de la grille (une boucle =for= pour les lignes : =i= , une boucle =for= pour les colonnes : =j=)
     - Si la grille contient déjà une valeur (=if tab[i][j]!=0=), la valeur ne peut être dans la case et donc elle est notée comme impossible : =possible[i][j]=0=
     - Si la grille contient le nombre que l'on teste :

     #+BEGIN_SRC python
for k in range(9):
    possible[i][k] = 0                                # on met toute la ligne à 0
    possible[k][j] = 0                                # on met toute la colonne  à 0
    possible[3*(carre//3)+k//3][3*(carre%3)+k%3] = 0  # et tout le carré
     #+END_SRC


     Ainsi s'il ne reste plus qu'un seul 1 dans une région (ligne, colonne ou carré) ce sera la valeur.


**** Élimination indirecte

     Le 1 de la ligne D impose un 1 dans la colonne g dans le rectangle milieu droit.

     Le 1 du rectangle inférieur droit ne peut donc pas être colonne g ni lignes H et J donc la seule possibilité est G, j. C'est cela que nous allons rechercher.

     J'ai numéroté les grands carrés de 0 à 8 le 0 correspondant à celui en haut à gauche, le 8 en  bas à droite.

     On passe en revue tous les carrés. Dans un carré si on rencontre une case possible pour notre valeur : 
     - On enregistre la position de sa colonne dans =debut_colonne= si c'est la première valeur  rencontrée (on a alors =debut_colonne = 10=)
     - Si c'est une des suivantes, on enregistre sa position dans fin_colonne.

       On connaît alors la colonne de la première possibilité et celle de la dernière.

       Si elles ont sur la même colonne, cela veut dire que la valeur cherchée ne se retrouvera pas dans  cette colonne dans un autre carré.

       On met donc toute cette colonne à 0 sauf dans le carré concerné.

       On recommence l'opération pour les lignes. Le raisonnement est identique. On aurait pu transposer  la grille et refaire d=strictement le même programme.

**** Analyse des lignes et des colonnes

     #+CAPTION: Analyse des lignes
     #+NAME:   FoncSudo: ou_le_nombre_peut_etre_analyseL
     #+INCLUDE: "FoncSudo.py" src python -n 457 :lines "457-467"


     On analyse ensuite les différentes lignes de la grille (listing [[FoncSudo: ou_le_nombre_peut_etre_analyseL]]) à la recherche d'un 1 isolé sur la ligne :
     - Si on rencontre un 1, on enregistre ses coordonnées (ligne,colonne) dans un tableau de  résultats. 
     - Si sur la ligne on a trouvé un seul 1, on renvoie ses coordonnées.

     On fait ensuite la même chose pour l'analyse des colonnes.
**** Analyse des carrés 3x3
     #+CAPTION: Analyse des carrés
     #+NAME:   FoncSudo: ou_le_nombre_peut_etre_analyseC
     #+INCLUDE: "FoncSudo.py" src python -n 485 :lines "485-497"
     Même chose avec les carrés.
*** Groupes nus et cachés
    À partir de ce niveau de difficulté, j'ai abandonné le tableau des 1 indiquant où il était possible de trouver une valeur au profit d'un tableau des possibles, indiquant pour chaque case une liste des prétendants et une liste vide si la case a une valeur trouvée.
*** Groupes nus
    Lorsque l'on rencontre dans une même région une paire de  (comme ici 7-8) en 2 endroits sur la même colonne, on est sûr que les 2 valeurs seront dans l'une des 2 cases et que par conséquent elles ne seront pas ailleurs dans la région. On pourra donc éliminer cette paire de tous les prétendants de la région excepté dans les 2 endroits où on les a trouvés.

    J'ai dans un premier temps  créé une fonction retrouvant les paires puis une autre les triplets, car le raisonnement est le même avec 3 triplets identiques dans une même région. (Voir FonctionsEnPlus)

    Je me suis ensuite rendu compte qu'un groupe abc pouvait être incomplet :

    Si on a abc puis abc puis ab, sans qu'il y ait égalité des groupes, on pouvait quand même éliminer des candidats de la région. De plus on pouvait faire 4 groupes de 4 ou 5 groupes de 5… et il aurait fallu faire autant de fonctions différentes. Je me suis donc consacré à la recherche des groupes nus quel que soit leur taille.
 

    #+CAPTION: groupes nus ligne
    #+NAME:   FoncSudo:groupes_nusL
    #+INCLUDE: "FoncSudo.py" src python -n 502 :lines "502-519"


    La fonction =groupes_nus_ligne= (listing [[FoncSudo:groupes_nusL]]) recherche de groupes nus dans une ligne.

    Les paramètres passés sont la grille des possibles et la ligne. La fonction modifie la grille des possibles.

    On teste toutes les colonnes, pour chaque colonne :
    - La liste est définie comme les candidats de la case de la ligne et de la colonne
    - On crée une liste d'index vide
    - On teste tous les éléments de la ligne (y compris ceux de la colonne considérée) : Si les candidats de la case sont inclus dans ceux de la liste et la case non vide et la liste non vide, on rajoute l'index (n° de la colonne) à la liste des index.
    - Si la liste contient autant d'éléments que l'on a trouvé de colonne, on a mis à jour un groupe nu, les éléments de cette liste sont donc dans la liste des index : =liste_index=. Ils ne sont donc pas dans les autres cases de la ligne.

    On élimine donc tous les éléments de la liste des autres cases de la ligne de la grille des possibles.
 
    Idem pour les colonnes avec la fonction =groupes_nus_colonne=. 
 
    Idem pour les carrés  avec la fonction =groupes_nus_carre= (listing [[FoncSudo:groupes_nus_carre]]) .

    #+CAPTION: groupes nus carré
    #+NAME:   FoncSudo:groupes_nus_carre
    #+INCLUDE: "FoncSudo.py" src python -n 538 :lines "538-557"



*** Groupes cachés
 
    On cherche cette fois des groupes de prétendants qui sont cachés parmi d'autres prétendants. 

    Comme ici le groupe 124 que l'on retrouve 2 fois entier et une fois partiellement.

    Ces 3 éléments sont donc forcément dans les 3 cases et par conséquent les autres prétendants n'y sont pas.

    L'idée pour trouver ces groupes : créer une liste des positions de chaque élément et comparer les éléments de la liste.

    #+CAPTION: groupes cachés ligne
    #+NAME:   FoncSudo:groupes_caches_ligne
    #+INCLUDE: "FoncSudo.py" src python -n 563 :lines "563-589"

 
    On teste une à une toutes les lignes de la grille (listing [[FoncSudo:groupes_caches_ligne]]). Pour chaque ligne :

    On crée la liste de toutes les positions possibles pour chacune des valeurs de 1 à 9 : =liste_position=

    On va ensuite comparer les listes de position aux autres et si l'on en trouve une incluse dans la référence, on va enregistrer sa valeur (index) dans la liste des index. L'index correspond à 1 près à la valeur du candidat.

    S'il y a autant de groupes que de candidats dans la liste :
    - On va créer la liste des valeurs en décalant de 1 les index de la liste des index
    - Pour tout =k= de la liste des positions: Pour toutes les valeurs =val=  qui ne sont pas dans la liste des valeurs, on va les ôter de la liste des possibles.

    Idem pour les carrés avec la fonction =groupes_caches_carre=.
 
    Idem pour les colonnes avec la fonction =groupes_caches_colonne=.

*** X-WING

    Si sur 2 lignes, on retrouve un même candidat sur 2 mêmes colonnes uniquement, dans les colonnes des sommets, cette valeur peut être éliminée de tous les prétendants des colonnes des sommets sauf celles des lignes des sommets.



    #+CAPTION: x-wing ligne
    #+NAME:   FoncSudo:x_wing_ligne
    #+INCLUDE: "FoncSudo.py" src python -n 657 :lines "657-683"



 
    Pour une valeur k donnée, on va enregistrer pour chaque ligne chaque fois que l'on a trouvé 2 fois la valeur : la ligne, la première position, la seconde position.

    À l'aide de deux index (index1 et index2) on va tester toutes les lignes 2 à 2.

    Si on retrouve deux listes ayant les 2 mêmes colonnes, on a un X-wing, alors :
    - Pour tous les éléments de la colonne de gauche qui ne sont pas sur la première ligne, si k est présent, on le retire de la liste des possibles.
    - Pour tous les éléments de la colonne de droite qui ne sont pas sur la première ligne, si k est présent, on le retire de la liste des possibles.

    On retourne la liste des possibles modifiée.
 
    Idem pour les colonnes avec la fonction =x_wing_colonne=.
    
*** Sword-fish
    C'est une extension du X-wing : si sur trois lignes différentes, un candidat n'apparaît que sur trois colonnes (voir exemples ci-contre), alors on supprime ce candidat sur les trois colonnes sauf sur les trois lignes de la grille des possibles.

    Pour cela j'ai créé 3 fonctions :
    - =liste_des_sommets= (listing [[FoncSudo:liste_des_sommets]]) qui enregistre toutes les paires de sommets

    #+CAPTION:liste des sommets
    #+NAME:   FoncSudo:liste_des_sommets
    #+INCLUDE: "FoncSudo.py" src python -n 740 :lines "740-751"

    Pour chacune des lignes, on ajoute à la =liste_sommets_ligne= la ligne et la  colonne où se trouve la valeur. Si dans =liste_sommets_ligne=, il y a 2 éléments, on rajoute ces 2 éléments à =liste_des_sommets=.


    - =groupes_de_3= (listing [[FoncSudo:groupes_de_3]]) qui vérifie que dans la liste des sommets on peut en trouver 3 alignés


    #+CAPTION:groupes de trois sommets alignés
    #+NAME:   FoncSudo:groupes_de_3
    #+INCLUDE: "FoncSudo.py" src python -n 752 :lines "752-766"


 
    On passe en paramètre : une grille des possibles, la liste des sommets trouvés avec la fonction précédente, la valeur recherchée. La fonction retourne la grille des possibles modifiée.
    La =liste_des_sommets= est rangée sous la forme =[ligne1, colonne1, ligne2, colonne2…]=.
    On commence par créer une liste =[0, 1, 2…]= comportant autant de valeurs qu'il y a de sommets.
    On va créer ensuite toutes les combinaisons possibles de 3 éléments des valeurs de la liste qui serviront d'indice pour tester les combinaisons des différents sommets avec la fonction =sword_fish= suivante.



    - =sword_fish= (listing [[FoncSudo:sword_fish]]) qui va supprimer sur les colonnes la valeur aux bons endroits.

    #+CAPTION:sword-fish
    #+NAME:   FoncSudo:sword_fish
    #+INCLUDE: "FoncSudo.py" src python -n 715 :lines "715-737"



 
    On fait la liste des =colonnes_trouvees= en rajoutant pour tous les sommets la colonne où il se trouve à condition que cette colonne n'ait pas déjà été enregistrée.
    Si le nombre de =colonnes_trouvees= n'est pas égal à 3 on ne peut pas faire de sword-fish et la 
    =grille_des_possibles= n'est pas modifiée.
    Sinon on vérifie que l'on a pas 2 listes de sommets identiques et là, on est sûr d'être dans le cas du sword-fish et l'on élimine de la grille des possibles  ce candidat sur les trois colonnes sauf sur les trois lignes.
 
    Des fonctions équivalentes sont créées pour un sword-fish sur les colonnes:
    - =sword_fish_c=
    - =liste_des_sommets_c=
    - =groupes_de_3_c=. 

*** Cas où un choix s'impose

    #+CAPTION:traitement des hypothèses
    #+NAME:   FoncSudo:essai_erreurs
    #+INCLUDE: "FoncSudo.py" src python -n 827 :lines "827-873"
 
    Lorsque qu'aucune des méthodes précédentes n'arrive à se sortir d'une impasse, il arrive que l'on soit obligé de faire une hypothèse pour une case (listing [[FoncSudo:essai_erreurs]]). C'est le cas si sur une ligne et une colonne on a les 2 mêmes prétendants en 2 cases différentes.

    La fonction =essai_erreur= reçoit comme paramètres : la grille des possibles, la grille de sudoku traitée et le choix (0 ou 1) que l'on va faire quand à l'hypothèse à prendre.

    On recherche dans tout le tableau de la =grille_des_possibles= un couple de candidats.
    On cherche si ce couple est présent sur la même ligne et sur la même colonne. Si c'est le cas on modifie la =grille_de_sudoku= et la =grille_des_possibles= avec le choix 0 ou 1 et l'on renvoie ces nouvelles grilles comme hypothèse de départ. Bien entendu si le premier choix ne mène pas à la solution finale,  il faudra tester le deuxième cas.
 
    Une deuxième variante de recherche est assuré par la fonction =essai_erreur2=  en cas de blocage avec recherche de 2 cases contenant les mêmes prétendants sur une même ligne, une même grande colonne ou un carré de 9.

** La résolution
*** Version 1: la fonction =resolution_=  (listing [[FoncSudo:resolutionV1]])
   #+CAPTION: la résolution V1
    #+NAME:   FoncSudo:resolutionV1
    #+INCLUDE: "FoncSudo.py" src python -n 881 :lines "881-927"
 

   On fait subir aux grilles toutes les fonctions les unes après les autres (sauf la fonction =essai_erreur=).

   Les deux premières bouclant jusqu'à ce qu'elles ne trouvent plus de solution (ce sont des fonctions 
   simples qui remplissent beaucoup de cases sans consommer trop de puissance de calcul).

 
   On crée 2 tableaux =memogrille= et =memopossible= au cas où on ait besoin de faire la fonction 
   =essai_erreur=.

   On boucle sur la fonction de résolution précédente jusqu'à ce que le tableau soit rempli ou un 
   nombre d'essais donné, pour éviter de rester coincé dans la boucle.

   Si la grille n'est pas résolue, on mémorise les 2 grilles (sudoku et possibles) on teste avec la fonction =essai_erreur= et le choix 0 si l'on peut résoudre.

   Si l'on n'a pas résolu on teste avec la fonction =essai_erreur= et le choix 1 si l'on peut résoudre.
*** Version 2: la fonction =resolution=
   #+CAPTION: la résolution V2 (début)
    #+NAME:   FoncSudo:resolutionV2d
    #+INCLUDE: "FoncSudo.py" src python -n 929 :lines "929-968"


   #+CAPTION: la résolution V2 (fin)
    #+NAME:   FoncSudo:resolutionV2f
    #+INCLUDE: "FoncSudo.py" src python -n  968:lines "968-996"

   Après avoir mémorisé l'état de la grille, on teste une des valeurs puis l'autre avec la première version de la fonction =essai_erreur= (listing [[FoncSudo:resolutionV2d]]). Si on n'a pas réussi, on revient à la grille mémorisée et l'on teste la deuxième version =essai_erreur2=. 

** Épilogue

   On doit pouvoir trouver des grilles qui ne peuvent pas être résolues.

   En particulier, je pense que la méthode sword-fish peut être étendue à des carrés imbriqués plus 
   complexes.

   Je n'ai pas non plus implémenté la théorie des chaînes.

   Et la fonction =essai_erreur= pourrait être étendue à des choix plus multiples.

   Mais ces fonctions arrivent à résoudre les sudokus les plus difficiles que j'ai pu trouver (diaboliques) et même ceux à 17 cases remplies.

* Troisième version
